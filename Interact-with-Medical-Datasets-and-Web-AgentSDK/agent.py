from openai import OpenAI
import os
import asyncio
from langchain_openai import ChatOpenAI
from openai import AsyncOpenAI
from agents import Agent, OpenAIChatCompletionsModel, Runner, function_tool, set_tracing_disabled
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_community.utilities import SQLDatabase
from langchain_community.agent_toolkits import create_sql_agent
from langchain_tavily import TavilySearch
from langgraph.prebuilt import create_react_agent

# load env
load_dotenv(dotenv_path="F:\Courses\Ostad\Assignments\Multi-Tool AI Agent to Interact with Medical Datasets and Web\medical_ai_agent\.env")  # Point to the parent directory
model_name = os.getenv("MODEL_NAME")
token = os.getenv("OPENAI_API_KEY") or os.getenv("API_KEY")
endpoint = os.getenv("OPENAI_API_BASE") or os.getenv("BASE_URL")

client = AsyncOpenAI(base_url=endpoint, api_key=token)
set_tracing_disabled(disabled=True)

# Initialize LLM 
llm = ChatOpenAI(
    model_name=model_name,
    openai_api_key=token,
    openai_api_base=endpoint,
    temperature=0.0,
)

# Create SQLDatabase wrappers 
heart_db = SQLDatabase.from_uri("sqlite:///F:/Courses/Ostad/Assignments/Multi-Tool AI Agent to Interact with Medical Datasets and Web/medical_ai_agent/databases/heart_disease.db")
cancer_db = SQLDatabase.from_uri("sqlite:///F:/Courses/Ostad/Assignments/Multi-Tool AI Agent to Interact with Medical Datasets and Web/medical_ai_agent/databases/cancer.db")
diabetes_db = SQLDatabase.from_uri("sqlite:///F:/Courses/Ostad/Assignments/Multi-Tool AI Agent to Interact with Medical Datasets and Web/medical_ai_agent/databases/diabetes.db")

# Create LangChain SQL agent executors for each DB
heart_agent_executor = create_sql_agent(
    llm=llm,
    db=heart_db,
    agent_type="openai-tools",
    verbose=False
)

cancer_agent_executor = create_sql_agent(
    llm=llm,
    db=cancer_db,
    agent_type="openai-tools",
    verbose=False
)

diabetes_agent_executor = create_sql_agent(
    llm=llm,
    db=diabetes_db,
    agent_type="openai-tools",
    verbose=False
)


@function_tool
def query_heart_db(user_query: str) -> str:
    """
    Run a natural-language question against the Heart Disease dataset.

    This function forwards the user's natural-language question to a LangChain SQL agent
    that has been configured with the heart disease SQLite database. The SQL agent will
    attempt to generate a read-only SQL SELECT statement, execute it against the DB,
    and return a concise, human-readable summary of the results.

    Args:
        user_query (str): A natural-language question about the heart disease dataset
            (e.g., "How many patients in the heart dataset are older than 60?").

    Returns:
        str: A natural-language answer summarizing the query results, or an error message
             if execution failed. The returned string may include the generated SQL and
             a short table of rows.

    Notes:
        - The underlying agent is expected to produce read-only SELECT statements.
        - Avoid sending sensitive or private patient information; this tool is intended
          for public or de-identified datasets only.
        - If the agent cannot produce a valid SQL statement or execution fails, an
          explanatory error will be returned.

    Example:
        >>> query_heart_db("What is the average age of patients with heart disease?")
        "Average age of patients with heart disease is 54.3 years..."
    """
    try:
        result = heart_agent_executor.invoke(user_query)
        return str(result)
    except Exception as e:
        return f"Error executing heart DB query: {e}"


@function_tool
def query_cancer_db(user_query: str) -> str:
    """
    Run a natural-language question against the Cancer dataset.

    This function forwards the user's natural-language question to a LangChain SQL agent
    that is connected to the cancer SQLite database. The agent will attempt to translate
    the query into a safe SQL SELECT, execute it, and return a readable summary of results.

    Args:
        user_query (str): A natural-language question about the cancer dataset
            (e.g., "How many malignant tumor cases are in the dataset?").

    Returns:
        str: A natural-language summary of the query results or an error message on failure.

    Notes:
        - The tool is designed for read-only reporting queries (SELECT). Do not expect it
          to perform DDL or DML operations.
        - Results are generated by the SQL agent; the format may include the SQL used and
          a small sample of result rows.

    Example:
        >>> query_cancer_db("Count malignant cases grouped by grade")
        "There are 123 malignant cases. Breakdown by grade: Grade I: 40, Grade II: 50, ..."
    """
    try:
        result = cancer_agent_executor.invoke(user_query)
        return str(result)
    except Exception as e:
        return f"Error executing cancer DB query: {e}"


@function_tool
def query_diabetes_db(user_query: str) -> str:
    """
    Run a natural-language question against the Diabetes dataset.

    This function forwards the user's natural-language question to a LangChain SQL agent
    configured with the diabetes SQLite database. The agent will convert the question to
    a safe SELECT statement, run it, and return a user-friendly summary of the results.

    Args:
        user_query (str): A natural-language question about the diabetes dataset
            (e.g., "How many patients have BMI greater than 30?").

    Returns:
        str: A natural-language response summarizing the query results, or an error string.

    Notes:
        - The agent is intended to generate read-only queries. If the agent attempts to
          produce a non-SELECT statement, execution may fail or be blocked depending on
          your SQL agent configuration.
        - Use clear, specific questions; including column names (if known) helps the LLM
          produce accurate SQL.

    Example:
        >>> query_diabetes_db("Show the average glucose level for patients with diabetes")
        "Average glucose level for diabetic patients is 142.6 mg/dL..."
    """
    try:
        result = diabetes_agent_executor.invoke(user_query)
        return str(result)
    except Exception as e:
        return f"Error executing diabetes DB query: {e}"



database_agent = Agent(
    name="Medical Database Specialist",
    instructions="""
    You are a medical database assistant specialized in analyzing patient data.
    
    ALWAYS start your response with: "üîç DATABASE AGENT: Now analyzing your question..."
    
    You can query three databases: Heart Disease, Breast Cancer, and Diabetes.

    - Use `query_heart_db` for questions about heart disease data and risk assessment
    - Use `query_cancer_db` for questions about cancer data and risk assessment
    - Use `query_diabetes_db` for questions about diabetes data and risk assessment

    For risk assessment questions:
    1. First query the relevant database to understand the data structure and patterns
    2. Look for patients with similar characteristics to the user's profile
    3. Calculate relevant statistics (percentages, averages, etc.)
    4. Provide a data-driven assessment based on the available patient records

    Always explain your analysis process and results clearly in natural language.
    Include relevant statistics and comparisons from the dataset to support your conclusions.
    """,
    model=OpenAIChatCompletionsModel(model=model_name, openai_client=client),
    tools=[query_heart_db, query_cancer_db, query_diabetes_db]
)

# Initialize Tavily Search Tool (only if API key is available)
tavily_api_key = os.getenv("TAVILY_API_KEY")
tavily_tool = TavilySearch(max_results=5, topic="general", tavily_api_key=tavily_api_key)
# Wrap in a LangChain agent
tavily_agent_executor = create_react_agent(llm, [tavily_tool])


@function_tool
def medical_web_search(user_query: str) -> str:
    """
    Search the web for general medical knowledge using Tavily.

    Args:
        user_query (str): The medical query in natural language.

    Returns:
        str: A summarized answer from Tavily search results.
    """
    try:
        if tavily_agent_executor is None:
            return "Web search is not available. Please add TAVILY_API_KEY to your .env file to enable web search functionality."
        
        result = tavily_agent_executor.invoke({"messages": [("user", user_query)]})
        return result["messages"][-1].content
    except Exception as e:
        return f"Error during Tavily search: {e}"
    
    
web_agent = Agent(
    name="Medical Web Knowledge Assistant",
    instructions="""
    You provide general medical knowledge by searching the web.
    
    ALWAYS start your response with: "üåê WEB AGENT: Searching for general medical information..."
    
    Use `medical_web_search` when the question is not about the databases,
    but about general medical information.
    """,
    model=OpenAIChatCompletionsModel(model="gpt-4o-mini", openai_client=client),
    tools=[medical_web_search]  
)

main_agent = Agent(
    name="Main Medical Assistant",
    instructions="""
    You are a medical assistant AI that routes questions to the appropriate specialist agent.
    
    Before routing, briefly say: "üìä ROUTING TO DATABASE AGENT" or "üåê ROUTING TO WEB AGENT" and explain why.
    
    **Route to database_agent for:**
    - Questions about specific datasets (heart disease, cancer, diabetes)
    - Statistical analysis requests (averages, counts, correlations)
    - Risk assessment based on patient characteristics (age, gender, medical history)
    - Numerical data analysis and comparisons
    - Questions involving specific patient attributes/features
    - Requests for data-driven predictions or classifications
    - Questions like "What is my risk of X given Y characteristics?"
    - Any question that requires analyzing stored patient data
    
    **Route to web_agent for:**
    - General medical knowledge and definitions
    - Treatment options and medical procedures
    - Latest medical research and news
    - General health advice not requiring data analysis
    - Questions about medical conditions that don't involve specific patient data
    
    Always choose database_agent when the question involves numerical analysis, risk assessment, or patient characteristics, even if it sounds like a general question.
    """,
    model=OpenAIChatCompletionsModel(model="gpt-4o-mini", openai_client=client),
    tools=[],
    handoffs=[database_agent, web_agent],
)

# def run_interactive(agent, client):
#     print("üß† Multi-tool medical agent (type 'exit' to quit)")
#     while True:
#         q = input("User: ")
#         if q.strip().lower() in ("exit", "quit"):
#             break
#         try:
#             response = client.agents.chat(
#                 agent_id=agent.id,
#                 messages=[{"role": "user", "content": q}]
#             )
#             print("AI:", response.output_text)
#         except Exception as e:
#             print("‚ö†Ô∏è Error:", e)


# Test the main agent
async def test_agent():
    print("üè• Testing Medical AI Agent...")
    
    # Test 1: General medical question
    print("\n1. Testing general medical knowledge:")
    response1 = await Runner.run(main_agent, "What are the common treatments for diabetes?")
    print("Response:", response1.final_output)
    
    # Test 2: Database query
    print("\n2. Testing database query:")
    response2 = await Runner.run(main_agent, "How many patients are in the heart disease dataset?")
    print("Response:", response2.final_output)

    # Test 3: Database query
    print("\n3. Testing database query:")
    response3 = await Runner.run(main_agent, "My age is 58, I am male, I have no smoking history and I have previous cancer history. What is my risk of cancer?")
    print("Response:", response3.final_output)

    print("\n‚úÖ Agent is working successfully!")

# Run the test
if __name__ == "__main__":
    asyncio.run(test_agent())
    # run_interactive(main_agent, client)

